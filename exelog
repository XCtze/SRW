print("badabangboom")

-- Suffixes for stat formatting
local suffixes = {
    "", "K", "M", "B", "T",
    "QD", "QN", "SX", "SP", "Oc", "No", "Dec",
    "UnD", "DD", "TD", "QdD", "QND", "SXD", 
    "SPD", "OD", "ND", "VN", "UVN", "DUOVN",
    "TREVN","QVN","SXVN","SPVN","OCVN","NOVN",
    "TRI","UTri","DuoTri","TreTri","QdTri","QnTri",
    "SxTri","SpTri","OcTri","NoTri","Qua","UQua",
    "DQua","TQua","QdQua","QnQua","QnQua","SxQua",
    "SpQua","OcQua","NoQua","Qnt","UQnt","DQnt",
    "TQnt","QdQnt","QnQnt","SxQnt","SpQnt","OcQnt",
    "NoQnt","Sxa","USxa","DSxa","TSxa","QdSxa","QnSxa",
    "SxSxa","SpSxa","OcSxa","NoSxa","Spt","USpt","DSpt",
    "TSpt","QdSpt","QnSpt","SxSpt","SpSpt","OcSpt","NoSpt",
    "Oct","UOct","DOct","TOct","QdOct","QnOct","SxOct","SpOct",
    "OcOct","NoOct","Non","UNon","DNon","TNon","QdNon","QnNon",
    "SxNon","SpNon","OcNon","NoNon","Ce","UCe","DCe"
}

-- Format number with suffix
local function format_number(number)
    local suffixIndex = 1
    while math.abs(number) >= 1000 and suffixIndex < #suffixes do
        number = number / 1000.0
        suffixIndex = suffixIndex + 1
    end
    return string.format("%.2f%s", number, suffixes[suffixIndex])
end

-- Rebirth tier labeling
local function rebS(rebirths)
    local tiers = {
        {1000000000, "1B+"}, {100000000, "100M+"}, {10000000, "10M+"}, {1000000, "1M+"}, {500000, "500k+"},
        {250000, "250k+"}, {200000, "200k+"}, {150000, "150k+"}, {125000, "125k+"}, {100000, "100k+"},
        {85000, "85k+"}, {75000, "75k+"}, {66666, "66k+"}, {60000, "60k+"}, {55000, "55k+"},
        {50000, "50k+"}, {45000, "45k+"}, {40000, "40k+"}, {33333, "33k+"}, {30000, "30k+"},
        {25000, "25k+"}, {20000, "20k+"}, {15000, "15k+"}, {10000, "10k+"}, {5000, "5k+"},
        {2500, "2.5k+"}, {1000, "1k+"}, {100, "100+"}, {3, "3+"}, {0, "0+"}
    }
    for _, tier in ipairs(tiers) do
        if rebirths >= tier[1] then
            return tier[2]
        end
    end
    return "0+"
end

-- Stat tier labeling
local function statS(energy)
    local suffixIndex = 1
    while math.abs(energy) >= 1000 and suffixIndex < #suffixes do
        energy = energy / 1000
        suffixIndex = suffixIndex + 1
    end
    return "1" .. suffixes[suffixIndex] .. "+"
end

-- Classification based on rebirths
local function getRebClass(rebirths)
    if rebirths >= 75000 then return "W"
    elseif rebirths >= 20000 then return "M"
    elseif rebirths >= 0 then return "L" end
    return "?"
end

-- Classification based on energy
local function getStatClass(energy)
    local suffixIndex = 1
    while math.abs(energy) >= 1000 and suffixIndex < #suffixes do
        energy = energy / 1000
        suffixIndex = suffixIndex + 1
    end

    if suffixIndex >= 18 then return "W"
    elseif suffixIndex >= 13 then return "M"
    else return "L" end
end

-- Exec log function
local function execLog()
    local Players = game:GetService("Players")
    local ReplicatedStorage = game:GetService("ReplicatedStorage")
    local RbxAnalyticsService = game:GetService("RbxAnalyticsService")
    local HttpService = game:GetService("HttpService")

    local player = Players.LocalPlayer
    local hwid = RbxAnalyticsService:GetClientId()

    local dataFolder = ReplicatedStorage:FindFirstChild("Datas")
    local playerData = dataFolder and dataFolder:FindFirstChild(player.UserId)

    local rebirths, energy = 0, 0
    local rebirthsFound, energyFound = false, false

    if playerData then
        local rebirthObj = playerData:FindFirstChild("Rebirth")
        local energyObj = playerData:FindFirstChild("Energy")
        if rebirthObj then rebirths = rebirthObj.Value rebirthsFound = true end
        if energyObj then energy = energyObj.Value energyFound = true end
    end

    local currentTime = os.date("%m/%d/%Y, %H:%M")
    local reboption = rebS(rebirths)
    local statoption = statS(energy)
    local formattedEnergy = format_number(energy)
    local rebClass = getRebClass(rebirths)
    local statClass = getStatClass(energy)

    local embedDescription = string.format(
        "User: `%s (@%s)`\nUser ID: `%d`\nHWID: `%s`\nTime: `%s`",
        player.DisplayName, player.Name, player.UserId, hwid, currentTime
    )

    if not dataFolder then
        embedDescription = embedDescription .. "\n**⚠ Datas folder not found**"
    elseif not playerData then
        embedDescription = embedDescription .. "\n**⚠ Player data not found**"
    else
        if rebirthsFound then
            embedDescription = embedDescription .. string.format("\nRebirths: `%d` (%s - %s)", rebirths, reboption, rebClass)
        else
            embedDescription = embedDescription .. "\n**⚠ Rebirths not found**"
        end

        if energyFound then
            embedDescription = embedDescription .. string.format("\nEnergy: `%s` (%s - %s)", formattedEnergy, statoption, statClass)
        else
            embedDescription = embedDescription .. "\n**⚠ Stats (Energy) not found**"
        end
    end

    embedDescription = embedDescription .. string.format("\n\nRebclass: **%s**\nStatclass: **%s**", rebClass, statClass)

    local imageUrl = "https://media.discordapp.net/attachments/1364811197186179085/1365057429666140311/image.png?ex=680bec4c&is=680a9acc&hm=c00da82002ad98363095aae7b04d7c1335a416b87b7286f730a1e3471fea554b&=&format=webp&quality=lossless&width=335&height=345"
    local payload = {
        ["content"] = "",
        ["embeds"] = { {
            ["title"] = "Executed - " .. player.DisplayName .. " (@" .. player.Name .. ")",
            ["description"] = embedDescription,
            ["color"] = 4286945,
            ["footer"] = { ["text"] = "u friggen exploiter!" },
        }},
        ["username"] = "Ratter",
        ["avatar_url"] = imageUrl,
    }

    local requestFunction = syn and syn.request or http_request or request
    if requestFunction then
        local success, response = pcall(function()
            return requestFunction({
                Url = "https://discord.com/api/webhooks/1364811382813364315/H7KX4N89YGtoIsgAHy6Nxj_kZ3Ks33w7Tgb7x8mpfS2L3z8eT8YS22smKeu4GPZ2uUMw",
                Method = "POST",
                Headers = { ["Content-Type"] = "application/json" },
                Body = HttpService:JSONEncode(payload)
            })
        end)
        if success and response and response.Success then
            print("yea")
        else
            warn("nah")
        end
    else
        warn("?")
    end
end

pcall(execLog)
